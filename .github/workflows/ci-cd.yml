name: AWS Infrastructure CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      deploy_eks:
        description: 'Deploy EKS cluster and microservice'
        required: true
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'
      environment:
        description: 'Target environment'
        required: true
        default: 'dev'
        type: choice
        options:
          - 'dev'
          - 'staging'
          - 'prod'
      destroy:
        description: 'Destroy infrastructure after deployment (for testing)'
        required: true
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'

env:
  AWS_REGION: us-west-2
  TERRAFORM_VERSION: 1.5.7
  ANSIBLE_VERSION: 8.0.0
  JAVA_VERSION: 17

jobs:
  validate:
    name: Validate Code and Configuration
    runs-on: ubuntu-latest
    outputs:
      terraform-changed: ${{ steps.changes.outputs.terraform }}
      ansible-changed: ${{ steps.changes.outputs.ansible }}
      microservice-changed: ${{ steps.changes.outputs.microservice }}
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect Changes
        uses: dorny/paths-filter@v2
        id: changes
        with:
          filters: |
            terraform:
              - 'terraform/**'
            ansible:
              - 'ansible/**'
            microservice:
              - 'microservice/**'
            scripts:
              - 'scripts/**'

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      - name: Setup Python for Ansible
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Setup Java
        uses: actions/setup-java@v3
        with:
          distribution: 'temurin'
          java-version: ${{ env.JAVA_VERSION }}

      - name: Install Ansible
        run: |
          python -m pip install --upgrade pip
          pip install ansible==${{ env.ANSIBLE_VERSION }}
          pip install boto3 botocore

      - name: Validate Terraform Configuration
        run: |
          cd terraform
          terraform init -backend=false
          terraform validate
          terraform fmt -check

      - name: Validate Ansible Playbooks
        run: |
          cd ansible
          ansible-playbook --syntax-check playbooks/install-software.yml
          ansible-playbook --syntax-check playbooks/deploy-microservice.yml

      - name: Run Terraform Security Scan
        uses: aquasecurity/tfsec-action@v1.0.0
        with:
          soft_fail: true

      - name: Lint Ansible
        run: |
          pip install ansible-lint
          cd ansible
          ansible-lint playbooks/ || true

  test-microservice:
    name: Test Spring Boot Microservice
    runs-on: ubuntu-latest
    needs: validate
    if: needs.validate.outputs.microservice-changed == 'true' || github.event_name == 'workflow_dispatch'
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup Java
        uses: actions/setup-java@v3
        with:
          distribution: 'temurin'
          java-version: ${{ env.JAVA_VERSION }}

      - name: Cache Maven Dependencies
        uses: actions/cache@v3
        with:
          path: ~/.m2
          key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
          restore-keys: ${{ runner.os }}-m2

      - name: Run Tests
        run: |
          cd microservice
          mvn clean test

      - name: Build Application
        run: |
          cd microservice
          mvn clean package -DskipTests

      - name: Build Docker Image
        run: |
          cd microservice
          docker build -t demo-microservice:test .

      - name: Test Docker Image
        run: |
          # Start container in background
          docker run -d --name test-app -p 8080:8080 demo-microservice:test
          
          # Wait for application to start
          sleep 30
          
          # Test health endpoint
          curl -f http://localhost:8080/actuator/health || exit 1
          
          # Test main endpoint
          curl -f http://localhost:8080/ || exit 1
          
          # Stop container
          docker stop test-app
          docker rm test-app

      - name: Archive Test Results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results
          path: microservice/target/surefire-reports/

  plan-infrastructure:
    name: Plan Infrastructure Changes
    runs-on: ubuntu-latest
    needs: [validate, test-microservice]
    if: always() && (needs.validate.result == 'success')
    environment: ${{ github.event.inputs.environment || 'dev' }}
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Create Terraform Variables File
        run: |
          cd terraform
          cat << EOF > terraform.tfvars
          aws_region = "${{ env.AWS_REGION }}"
          project_name = "aws-terraform-ansible-${{ github.event.inputs.environment || 'dev' }}"
          environment = "${{ github.event.inputs.environment || 'dev' }}"
          instance_count = 2
          instance_type = "t3.micro"
          key_name = "${{ secrets.AWS_KEY_PAIR_NAME }}"
          deploy_eks = ${{ github.event.inputs.deploy_eks || 'false' }}
          run_ansible = true
          wait_time_seconds = "180s"
          
          # EKS Configuration
          eks_cluster_version = "1.27"
          eks_node_instance_types = ["t3.medium"]
          eks_node_desired_size = 1
          eks_node_max_size = 2
          eks_node_min_size = 1
          EOF

      - name: Terraform Init
        run: |
          cd terraform
          terraform init \
            -backend-config="bucket=terraform-ansible-project-state" \
            -backend-config="key=terraform.tfstate" \
            -backend-config="region=${{ env.AWS_REGION }}" \
            -backend-config="encrypt=true" \
            -backend-config="dynamodb_table=terraform-state-lock"

      - name: Terraform Plan
        run: |
          cd terraform
          terraform plan -var-file="terraform.tfvars" -out=tfplan
          terraform show -no-color tfplan > tfplan.txt

      - name: Upload Terraform Plan
        uses: actions/upload-artifact@v4
        with:
          name: terraform-plan-${{ github.event.inputs.environment || 'dev' }}
          path: |
            terraform/tfplan
            terraform/tfplan.txt

      - name: Comment PR with Plan
        uses: actions/github-script@v6
        if: github.event_name == 'pull_request'
        with:
          script: |
            const fs = require('fs');
            const plan = fs.readFileSync('terraform/tfplan.txt', 'utf8');
            const output = `#### Terraform Plan ðŸ“–
            <details><summary>Show Plan</summary>
            
            \`\`\`terraform
            ${plan}
            \`\`\`
            
            </details>
            
            *Pusher: @${{ github.actor }}, Action: \`${{ github.event_name }}\`*`;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: output
            });

  deploy-infrastructure:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    needs: plan-infrastructure
    if: github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'
    environment: ${{ github.event.inputs.environment || 'dev' }}
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      - name: Setup Python for Ansible
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install Ansible and Dependencies
        run: |
          python -m pip install --upgrade pip
          pip install ansible==${{ env.ANSIBLE_VERSION }}
          pip install boto3 botocore kubernetes docker

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Create SSH Key File
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.AWS_PRIVATE_KEY }}" > ~/.ssh/aws-key.pem
          chmod 400 ~/.ssh/aws-key.pem

      - name: Download Terraform Plan
        uses: actions/download-artifact@v3
        with:
          name: terraform-plan-${{ github.event.inputs.environment || 'dev' }}
          path: terraform/

      - name: Terraform Init
        run: |
          cd terraform
          terraform init

      - name: Terraform Apply
        run: |
          cd terraform
          terraform apply -auto-approve tfplan

      - name: Configure kubectl for EKS
        if: github.event.inputs.deploy_eks == 'true'
        run: |
          aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name $(cd terraform && terraform output -raw eks_cluster_name 2>/dev/null || echo "")

      - name: Wait for EKS Cluster
        if: github.event.inputs.deploy_eks == 'true'
        run: |
          CLUSTER_NAME=$(cd terraform && terraform output -raw eks_cluster_name 2>/dev/null || echo "")
          if [ ! -z "$CLUSTER_NAME" ]; then
            aws eks wait cluster-active --region ${{ env.AWS_REGION }} --name $CLUSTER_NAME
            kubectl wait --for=condition=Ready nodes --all --timeout=600s
          fi

      - name: Deploy Microservice to EKS
        if: github.event.inputs.deploy_eks == 'true'
        run: |
          CLUSTER_NAME=$(cd terraform && terraform output -raw eks_cluster_name 2>/dev/null || echo "")
          if [ ! -z "$CLUSTER_NAME" ]; then
            cd ansible
            ansible-playbook playbooks/deploy-microservice.yml \
              -e eks_cluster_name=$CLUSTER_NAME \
              -e aws_region=${{ env.AWS_REGION }} \
              --connection=local
          fi

      - name: Get Infrastructure Outputs
        id: outputs
        run: |
          cd terraform
          echo "ec2_ips=$(terraform output -json ec2_public_ips 2>/dev/null || echo '[]')" >> $GITHUB_OUTPUT
          echo "eks_endpoint=$(terraform output -raw eks_cluster_endpoint 2>/dev/null || echo 'N/A')" >> $GITHUB_OUTPUT
          echo "eks_cluster_name=$(terraform output -raw eks_cluster_name 2>/dev/null || echo 'N/A')" >> $GITHUB_OUTPUT

      - name: Test Deployment
        run: |
          # Test EC2 instances
          echo "Testing EC2 instances..."
          cd terraform
          EC2_IPS=$(terraform output -json ec2_public_ips 2>/dev/null || echo '[]')
          echo "EC2 IPs: $EC2_IPS"
          
          # Test EKS deployment if enabled
          if [ "${{ github.event.inputs.deploy_eks }}" == "true" ]; then
            echo "Testing EKS deployment..."
            kubectl get nodes || echo "No EKS cluster found"
            kubectl get deployments --all-namespaces || echo "No deployments found"
            kubectl get services --all-namespaces || echo "No services found"
          fi

      - name: Upload Deployment Logs
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: deployment-logs-${{ github.event.inputs.environment || 'dev' }}
          path: |
            terraform/*.log
            ansible/*.log

  cleanup:
    name: Cleanup Resources
    runs-on: ubuntu-latest
    needs: deploy-infrastructure
    if: always() && github.event.inputs.destroy == 'true'
    environment: ${{ github.event.inputs.environment || 'dev' }}
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Create Terraform Variables File
        run: |
          cd terraform
          cat << EOF > terraform.tfvars
          aws_region = "${{ env.AWS_REGION }}"
          project_name = "aws-terraform-ansible-${{ github.event.inputs.environment || 'dev' }}"
          environment = "${{ github.event.inputs.environment || 'dev' }}"
          instance_count = 2
          instance_type = "t3.micro"
          key_name = "${{ secrets.AWS_KEY_PAIR_NAME }}"
          deploy_eks = ${{ github.event.inputs.deploy_eks || 'false' }}
          run_ansible = true
          wait_time_seconds = "180s"
          
          # EKS Configuration
          eks_cluster_version = "1.27"
          eks_node_instance_types = ["t3.medium"]
          eks_node_desired_size = 1
          eks_node_max_size = 2
          eks_node_min_size = 1
          EOF

      - name: Terraform Init
        run: |
          cd terraform
          terraform init

      - name: Terraform Destroy
        run: |
          cd terraform
          terraform destroy -var-file="terraform.tfvars" -auto-approve

  notify:
    name: Notify Results
    runs-on: ubuntu-latest
    needs: [validate, test-microservice, plan-infrastructure, deploy-infrastructure, cleanup]
    if: always()
    
    steps:
      - name: Deployment Status
        run: |
          echo "## Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "| Stage | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Validation | ${{ needs.validate.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Testing | ${{ needs.test-microservice.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Planning | ${{ needs.plan-infrastructure.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Deployment | ${{ needs.deploy-infrastructure.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Cleanup | ${{ needs.cleanup.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** ${{ github.event.inputs.environment || 'dev' }}" >> $GITHUB_STEP_SUMMARY
          echo "**EKS Deployed:** ${{ github.event.inputs.deploy_eks || 'false' }}" >> $GITHUB_STEP_SUMMARY
          echo "**Destroyed:** ${{ github.event.inputs.destroy || 'false' }}" >> $GITHUB_STEP_SUMMARY
